=== genius_utils.py ===
import os
import lyricsgenius
from dotenv import load_dotenv

load_dotenv()

GENIUS_TOKEN = os.getenv("GENIUS_API_TOKEN")

genius = lyricsgenius.Genius(
    GENIUS_TOKEN, skip_non_songs=True, excluded_terms=["(Remix)", "(Live)"], timeout=10
)


def get_lyrics(song_name, artist_name):
    """
    Fetch raw (unsynced) lyrics from Genius as a fallback.
    """
    try:
        song = genius.search_song(song_name, artist_name)
        if song and song.lyrics:
            return song.lyrics
        return None
    except Exception as e:
        print(f"[Genius Error] {e}")
        return None



=== gpt_dj.py ===


import os
import openai
import requests
import logging
from dotenv import load_dotenv
from gpt_utils import count_tokens
from logger_utils import setup_logger
from rich.console import Console
from rich.text import Text
from rich.panel import Panel

console = Console()

class RadioFreeDJ:
    def __init__(
        self,
        api_key=None,
        active_model=None,
        log_path="requests.log",
        system_prompt=None,
        on_response=None,
    ):
        load_dotenv()

        self.api_key = api_key or os.getenv("OPENAI_API_KEY")
        self.active_model = active_model or os.getenv("GPT_MODEL", "gpt-4o")
        self.log_path = os.path.abspath(log_path)
        self.system_prompt = system_prompt or os.getenv("SYSTEM_PROMPT", "")
        self.on_response = on_response

        use_local = os.getenv("USE_LOCAL_LLM", "false").lower() == "true"
        self.use_local_llm = use_local
        self.local_llm_url = os.getenv("LOCAL_LLM_API")

        if not self.use_local_llm and not self.api_key:
            raise ValueError("OPENAI_API_KEY is not set and local LLM is not enabled.")

        if not self.use_local_llm:
            self.client = openai.OpenAI(api_key=self.api_key)

        self.logger = setup_logger("RadioFreeDJ", self.log_path)

        # For toggling logs view
        self.show_logs = False

    def count_tokens(self, prompt: str) -> int:
        try:
            return count_tokens(prompt, self.active_model)
        except Exception as e:
            console.print(f"[red]Token count error:[/red] {e}")
            return 0

    def ask(self, prompt: str) -> str | None:
        token_count = self.count_tokens(prompt)
        self.logger.debug(f"Prompt sent ({token_count} tokens):\n{prompt}")
        
        console.print(f"[cyan]🔍 Sending to GPT model:[/cyan] {self.active_model}")
        console.print(Panel(prompt, title="🧠 GPT Prompt"))

        try:
            response = self._ask_local(prompt) if self.use_local_llm else self._ask_openai(prompt)
            self.logger.info(f"Response for prompt:\n{response}")
            if self.on_response:
                try:
                    self.on_response(prompt, response)
                except Exception as cb_err:
                    self.logger.error(f"on_response callback error: {cb_err}")
            return response
        except Exception as e:
            self.logger.error(f"Error getting GPT response: {e}")
            return None

    def _ask_openai(self, prompt: str) -> str:
        try:
            messages = []
            if self.system_prompt:
                messages.append({"role": "system", "content": self.system_prompt})
            messages.append({"role": "user", "content": prompt})

            response = self.client.chat.completions.create(
                model=self.active_model,
                messages=messages
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            self.logger.error(f"OpenAI request failed: {e}")
            console.print(Panel(str(e), title="❌ GPT API Error", border_style="red"))
            return "[gpt-error]"


    def _ask_local(self, prompt: str) -> str:
        if not self.local_llm_url:
            raise ValueError("LOCAL_LLM_API is not set in .env")

        payload = {"model": self.active_model, "messages": []}
        if self.system_prompt:
            payload["messages"].append({"role": "system", "content": self.system_prompt})
        payload["messages"].append({"role": "user", "content": prompt})

        resp = requests.post(self.local_llm_url, json=payload, timeout=5)
        resp.raise_for_status()
        return resp.json()["choices"][0]["message"]["content"].strip()

    def toggle_log_view(self):
        self.show_logs = not self.show_logs

    def render_log_panel(self) -> Panel:
        if not self.show_logs:
            return Panel("[dim]Logs hidden. Toggle with 'v'.[/dim]", title=" Logs", border_style="gray")
        try:
            if os.path.exists(self.log_path):
                with open(self.log_path, "r", encoding="utf-8") as f:
                    lines = f.readlines()[-20:]
                text = Text("".join(lines), style="green")
            else:
                text = Text("[No log file found]", style="red")
        except Exception as e:
            text = Text(f"Error reading log file: {e}", style="red")
        return Panel(text, title=" Logs", border_style="gray")




=== gpt_utils.py ===
import os
import tiktoken
from rich.console import Console
from rich.panel import Panel

console = Console()


def count_tokens(prompt, active_model):
    try:
        encoding = tiktoken.encoding_for_model(active_model)
        return len(encoding.encode(prompt))
    except Exception as e:
        console.print(Panel(str(e), title=" Token Count Error", border_style="red"))
        return len(prompt.split())


def log_request(prompt, active_model, token_count, log_path="radio.log"):
    try:
        log_path = os.path.abspath(log_path)
        with open(log_path, "a") as log_file:
            log_file.write(f"\n--- RadioFreeGPT Request ---\n")
            log_file.write(f"Model: {active_model}\n")
            log_file.write(f"Prompt:\n{prompt}\n")
            log_file.write(f"Tokens used: {token_count}\n")
            log_file.write(f"-----------------------------\n")
        console.print(f"[green] Logged request to:[/green] {log_path}")
    except Exception as e:
        console.print(Panel(str(e), title=" Log Write Error", border_style="red"))



=== logger_utils.py ===
# logger_utils.py

import logging
import os

# logfile = os.path.resolve().parent(__file__).parent / log_path

def setup_logger(name: str, log_path: str = "./logs/requests.log") -> logging.Logger:
    """
    Set up and return a logger with the given name and log file path.
    """
    logger = logging.getLogger(name)
    if not logger.handlers:
        os.makedirs(os.path.dirname(log_path), exist_ok=True) if os.path.dirname(
            log_path
        ) else None
        handler = logging.FileHandler(log_path)
        formatter = logging.Formatter("[%(asctime)s] %(levelname)s: %(message)s")
        handler.setFormatter(formatter)
        logger.setLevel(logging.DEBUG)
        logger.addHandler(handler)
    return logger

if __name__ == "__main__":
    # setup_logger(name="app_logger")
    logger = setup_logger(name="app_logger")
    logger.info(f"Successfully set up {logger}")



=== lyrics_sync.py ===
import time
import re
import json
from rich.text import Text
from genius_utils import get_lyrics
import requests
from requests.exceptions import RequestException
import logging

# logging.basicConfig(
#     level=logging.DEBUG,
#     format="%(asctime)s %(name)s %(levelname)s: %(message)s",
# )

logging.disable(logging.CRITICAL)


class LyricsSyncManager:
    API_URL = "https://lrclib.net/api/get"

    def __init__(self, spotify_controller):
        self.spotify = spotify_controller
        self.timestamps = []
        self.lines = []
        self.current_index = 0
        self.logger = logging.getLogger(self.__class__.__name__)

    def start(self, track_name, artist_name, album_name="", duration_ms=0):
        self.current_index = 0
        try:
            ts, ls = self.fetch_lyrics(
                artist_name=artist_name,
                track_name=track_name,
                album_name=album_name,
                duration_ms=duration_ms,
            )
            if ts and ls:
                self.timestamps, self.lines = ts, ls
            else:
                raise ValueError("Empty LRC result")
        except Exception as e:
            self.logger.warning(f"No lyrics for '{track_name}' by '{artist_name}': {e}")
            self.timestamps = [0]
            self.lines = ["[dim]No lyrics found[/dim]"]

    def fetch_lyrics(self, artist_name, track_name, album_name, duration_ms):
        # skip any sub‑one‑second durations
        if duration_ms < 1000:
            self.logger.debug("duration_ms < 1000 (%d), skipping fetch", duration_ms)
            return [], []

        # convert to seconds and clamp
        secs = max(1, min(duration_ms // 1000, 3600))
        params = {
            "artist_name": artist_name,
            "track_name": track_name,
            "album_name": album_name,
            "duration": secs,
        }
        self.logger.debug("Requesting LRC: %s with %s", self.API_URL, params)

        try:
            resp = requests.get(self.API_URL, params=params, timeout=5)
            self.logger.debug("HTTP %s %s", resp.status_code, resp.url)
            snippet = resp.text.strip().splitlines()[:3]
            self.logger.debug("Body snippet:\n%s", "\n".join(snippet))

            resp.raise_for_status()
            text = resp.text.strip()

            # if JSON, extract the syncedLyrics field
            if text.startswith("{"):
                data = json.loads(text)
                lrc_text = data.get("syncedLyrics") or data.get("plainLyrics", "")
                if not lrc_text:
                    raise ValueError("No 'syncedLyrics' in JSON response")
            else:
                lrc_text = text

            return self.parse_lrc(lrc_text)

        except requests.RequestException as err:
            self.logger.error("LRC fetch error: %s", err)
            return [], []
        except json.JSONDecodeError:
            # not JSON, fall back to raw LRC parse
            return self.parse_lrc(resp.text)

    def parse_lrc(self, lrc_text):
        """
        Parse LRC “[MM:SS.ss] line” into ([ms…], [str…]).
        """
        pattern = re.compile(r"\[(\d+):(\d+\.\d+)\](.*)")
        ts, lines = [], []
        for line in lrc_text.splitlines():
            m = pattern.match(line)
            if not m:
                continue
            mins = int(m.group(1))
            secs = float(m.group(2))
            ts.append(int((mins * 60 + secs) * 1000))
            lines.append(m.group(3).strip())
        return ts, lines

    def sync(self, progress_ms):
        while (
            self.current_index + 1 < len(self.timestamps)
            and progress_ms >= self.timestamps[self.current_index + 1]
        ):
            self.current_index += 1

    def get_text(self):
        return self.lines[self.current_index] if self.lines else ""



=== main.py ===
import threading
import time
import os
import json
import re
from dotenv import load_dotenv
from datetime import datetime
from time import sleep

from gpt_dj import RadioFreeDJ
from spotify_utils import SpotifyController
from upnext import UpNextManager
from genius_utils import get_lyrics
from lyrics_sync import LyricsSyncManager
from requests.exceptions import ReadTimeout, RequestException

from queue import Queue
from rich.progress import Progress, BarColumn, TextColumn, TimeElapsedColumn
from rich.console import Console
from rich.panel import Panel
from rich.layout import Layout
from rich.live import Live
from rich.prompt import Prompt
from rich.text import Text

from logger_utils import setup_logger

# === Load Environment Variables ===
load_dotenv()

# === Load Prompt Templates ===
prompts_path = os.path.join(os.path.dirname(__file__), "prompts.json")
with open(prompts_path, "r", encoding="utf-8") as f:
    prompt_templates = json.load(f)

# === Setup Logging ===
log_path = os.path.join(os.path.dirname(__file__), "requests.log")
logger = setup_logger("FreeRadioMain", log_path)

# --- Command Logging Setup ---
COMMAND_LABELS = {
    "1": "Auto-DJ",
    "s": "Save Song",
    "d": "Dislike Song",
    "right": "Next Track",
    "left": "Previous Track",
    "2": "Queue One Song",
    "3": "Queue Ten Songs",
    "4": "Queue Playlist",
    "5": "Queue Theme Playlist",
    "6": "Song Insight",
    "t": "Toggle Mode",
    "0": "Quit",
    "l": "Toggle Lyrics View",
    "g": "Toggle GPT Log",
    "j": "Cursor Down",
    "k": "Cursor Up",
}
COMMAND_LOG_FILE = os.path.join(os.path.dirname(__file__), "commands.log")


def log_command(choice: str):
    label = COMMAND_LABELS.get(choice, "Unknown")
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    entry = f"{timestamp} - {choice} → {label}\n"
    try:
        with open(COMMAND_LOG_FILE, "a", encoding="utf-8") as f:
            f.write(entry)
    except Exception as e:
        logger.warning(f"Could not write command log: {e}")
    return label


# === Initialize UI State ===
show_lyrics = True
lyrics_view_mode = "chunk"
lyrics_cursor = 0

show_gpt_log = True
command_log_buffer = []
notifications = []
user_input_queue = Queue()

gpt_log_buffer = []


GPT_LOG_FILE = os.path.expanduser("~/RadioFree/logs/gpt_log.jsonl")

def log_gpt(prompt: str, response: str):
    entry = {
        "timestamp": datetime.now().isoformat(),
        "prompt": prompt.strip(),
        "response": (response or "[No response]").strip()
    }
    gpt_log_buffer.append((entry["prompt"], entry["response"]))
    if len(gpt_log_buffer) > 50:
        gpt_log_buffer.pop(0)

    try:
        os.makedirs(os.path.dirname(GPT_LOG_FILE), exist_ok=True)
        with open(GPT_LOG_FILE, "a", encoding="utf-8") as f:
            f.write(json.dumps(entry) + "\n")
    except Exception as e:
        logger.warning(f"Failed to write GPT log: {e}")



# === instantiate radiofreedj ===
api_key = os.getenv("OPENAI_API_KEY")
gpt_model = os.getenv("gpt_model", "gpt-4o-mini")
if not api_key:
    raise ValueError("OPENAI_API_KEY is not set in .env!")

gpt_dj = RadioFreeDJ(
    api_key=api_key,
    active_model=gpt_model,
    log_path=log_path,
    on_response=log_gpt,
)

# === other components ===
spotify_controller = SpotifyController()
upnext = UpNextManager(gpt_dj, spotify_controller, prompt_templates)
lyrics_manager = LyricsSyncManager(spotify_controller)
console = Console()
last_song = (None, None)

# ─────────────────────────────────────────────────────────────
# Event Notifications
# ─────────────────────────────────────────────────────────────

def notify(message: str, style="bold yellow"):
    notifications.append(Text(message, style=style))
    if len(notifications) > 3:
        notifications.pop(0)

def log_song_history(song_name, artist_name, queued_by="unknown", liked=False, skipped=False):
    history_dir = os.path.expanduser("~/RadioFree/logs")
    os.makedirs(history_dir, exist_ok=True)
    history_file = os.path.join(history_dir, "song_history.jsonl")

    entry = {
        "track_name": song_name,
        "artist_name": artist_name,
        "timestamp": datetime.now().isoformat(),
        "queued_by": queued_by,
        "liked": liked,
        "skipped": skipped,
        "played_count": 1,
        "recommended_count": 1 if queued_by == "gpt" else 0
    }

    with open(history_file, "a") as f:
        f.write(json.dumps(entry) + "\n")

# ─────────────────────────────────────────────────────────────
# Rich UI Layout & Helpers
# ─────────────────────────────────────────────────────────────

def render_queue_status() -> Text:
    queue_status = Text.from_markup(
        f"[bold]Mode:[/bold] {upnext.mode}\n"
        f"[bold]Queued Songs:[/bold] {len(upnext.queue)}\n"
    )
    if upnext.queue:
        next_up = upnext.queue[0]
        queue_status.append(
            Text.from_markup(
                f"[bold]Next Up:[/bold] {next_up['track_name']} - {next_up['artist_name']}"
            )
        )
    else:
        queue_status.append(Text.from_markup("[dim]No songs queued.[/dim]"))
    return queue_status


def render_progress_bar(progress_ms, duration_ms):
    percent = min(progress_ms / duration_ms, 1.0) if duration_ms else 0
    bar_length = 30
    filled = int(bar_length * percent)
    empty = bar_length - filled
    bar = f"[cyan][{'█' * filled}{'░' * empty}][/cyan]"
    return f"{bar} {int(percent * 100)}%"


def render_gpt_log() -> Text:
    panel_text = Text()
    if show_gpt_log and gpt_log_buffer:
        _, latest = gpt_log_buffer[-1]
        panel_text.append(latest, style="cyan")
    else:
        panel_text.append("[dim]GPT log hidden (press [bold]g[/bold] to show)[/dim]")
    return panel_text


def get_menu_text():
    mode_label = "Playlist" if upnext.mode == "playlist" else "Smart"
    menu = [
        "[bold]1.[/bold] 󰼛 Tune in to RadioFree󰲿 with DJ gpt-4o-mini 󱚣 ",
        "[bold]2.[/bold] Queue 1 recommended song",
        "[bold]3.[/bold] Queue 10 recommendations",
        "[bold]s.[/bold] Save song to favorites",
        "[bold]d.[/bold] Dislike current song",
        "[bold]4.[/bold] Queue 15-song playlist",
        "[bold]5.[/bold] Queue 10-song theme playlist",
        "[bold]6.[/bold] Get info on current song",
        f"[bold]t.[/bold] Toggle playback mode ({mode_label} Mode)",
        "[bold]0.[/bold] Quit",
    ]
    if command_log_buffer:
        menu.append(f"\n[bold]Last:[/bold] {command_log_buffer[-1]}")
    return Text.from_markup("\n".join(menu))


def create_layout(song_name, artist_name):
    layout = Layout()
    layout.split(
        Layout(name="header", size=3),
        Layout(name="lyrics", ratio=2),
        Layout(name="lower", ratio=3),
    )
    layout["lower"].split_row(
        Layout(name="menu", ratio=1),
        Layout(name="gpt", ratio=2),
        Layout(name="queue", ratio=1),
    )

    # Queue panel
    layout["queue"].update(
        Panel(render_queue_status(), title="  Coming Up Next", border_style="blue")
    )

    # Header panel
    playback = spotify_controller.sp.current_playback() or {}
    progress = playback.get("progress_ms", 0)
    duration = playback.get("item", {}).get("duration_ms", 0)
    elapsed = time.strftime("%M:%S", time.gmtime(progress // 1000))
    total = time.strftime("%M:%S", time.gmtime(duration // 1000))
    progress_bar = render_progress_bar(progress, duration)
    subtitle = "\n".join(n.plain for n in notifications[-3:])
    layout["header"].update(
        Panel(
            f"[bold green]  Now Playing:[/bold green] [yellow]{song_name}[/yellow] by [cyan]{artist_name}[/cyan]  [dim]| {elapsed} / {total}[/dim]",
            title=f"RadioFreeDJ {progress_bar}",
            subtitle=subtitle,
            subtitle_align="right",
        )
    )

    # Lyrics panel
    lyrics_manager.sync(progress)
    panel_text = Text()
    lines, idx = lyrics_manager.lines, lyrics_manager.current_index
    if lyrics_view_mode == "chunk":
        start = max(0, idx - 3)
        for i, line in enumerate(lines[start : start + 8], start):
            prefix, style = ("", "bold italic yellow") if i == idx else ("-", None)
            panel_text.append(f"{prefix} {line}\n", style=style)
    else:
        for i, line in enumerate(lines):
            style = "bold italic yellow" if i == lyrics_cursor else None
            panel_text.append(f"  {line}\n", style=style)
    layout["lyrics"].update(Panel(panel_text, title="󰎆 Lyrics", border_style="cyan"))

    # Menu & GPT panels
    layout["menu"].update(
        Panel(get_menu_text(), title="󰮫 Main Menu", border_style="green")
    )
    layout["gpt"].update(
        Panel(render_gpt_log(), title=" RadioFree󰲿", border_style="magenta")
    )

    return layout


# ─────────────────────────────────────────────────────────────
# GPT Actions (using prompt_templates)
# ─────────────────────────────────────────────────────────────
def recommend_next_song(song_name, artist_name):
    tpl = prompt_templates["recommend_next_song"]
    prompt = tpl.format(song_name=song_name, artist_name=artist_name)
    resp = gpt_dj.ask(prompt)
    log_gpt(prompt, resp)
    if resp:
        console.print(
            Panel(resp, title="  RadioFree󰲿 Recommended", border_style="magenta")
        )
    return resp

def create_playlist(song_name, artist_name):
    tpl = prompt_templates["create_playlist"]
    prompt = tpl.format(song_name=song_name, artist_name=artist_name)
    resp = gpt_dj.ask(prompt)
    log_gpt(prompt, resp)
    logger.info(f"[create_playlist] Prompt:\n{prompt}")
    logger.info(f"[create_playlist] Response:\n{resp}")
    if resp:
        console.print(Panel(resp, title="󰐑 FreeRadio Playlist", border_style="magenta"))

def theme_based_playlist():
    theme = Prompt.ask("Enter a theme").strip()
    tpl = prompt_templates["theme_based_playlist"]
    prompt = tpl.format(theme=theme)
    resp = gpt_dj.ask(prompt)
    log_gpt(prompt, resp)
    logger.info(f"[theme_based_playlist] Prompt:\n{prompt}")
    logger.info(f"[theme_based_playlist] Response:\n{resp}")
    if resp:
        console.print(
            Panel(resp, title=f"󰐑 Themed Playlist: {theme}", border_style="magenta")
        )

def generate_radio_intro(track_name, artist_name):
    tpl = prompt_templates["generate_radio_intro"]
    prompt = tpl.format(track_name=track_name, artist_name=artist_name)
    resp = gpt_dj.ask(prompt)
    log_gpt(prompt, resp)
    logger.info(f"[generate_radio_intro] Prompt:\n{prompt}")
    logger.info(f"[generate_radio_intro] Response:\n{resp}")
    return resp or "󱚢 [DJ dead air] No intro available."

def song_insights(song_name, artist_name):
    tpl = prompt_templates["song_insights"]
    prompt = tpl.format(song_name=song_name, artist_name=artist_name)
    resp = gpt_dj.ask(prompt)
    log_gpt(prompt, resp)
    logger.info(f"[song_insights] Prompt:\n{prompt}")
    logger.info(f"[song_insights] Response:\n{resp}")
    if resp:
        console.print(Panel(resp, title=" RadioFree DJ - gpt-4o-mini", border_style="cyan"))

# ─────────────────────────────────────────────────────────────
# User Interaction Loop
# ─────────────────────────────────────────────────────────────
def read_input():
    try:
        while True:
            choice = Prompt.ask("[bold green]   Select an option[/bold green]")
            user_input_queue.put(choice)
            log_command(choice)
    except KeyboardInterrupt:
        pass

def process_user_input(choice: str, current_song: str, current_artist: str):
    label = log_command(choice)
    command_log_buffer.append(f"{choice} → {label}")
    if len(command_log_buffer) > 50:
        command_log_buffer.pop(0)
    notify(f"Command: {label}", style="green")

    global lyrics_view_mode, lyrics_cursor, show_gpt_log

    if choice == "l":
        if lyrics_view_mode == "chunk":
            lyrics_view_mode = "full"
            lyrics_cursor = lyrics_manager.current_index
        else:
            lyrics_view_mode = "chunk"
    elif choice == "g":
        show_gpt_log = not show_gpt_log
    elif lyrics_view_mode == "full" and choice == "j":
        lyrics_cursor = min(lyrics_cursor + 1, len(lyrics_manager.lines) - 1)
    elif lyrics_view_mode == "full" and choice == "k":
        lyrics_cursor = max(lyrics_cursor - 1, 0)
    elif choice == "0":
        raise KeyboardInterrupt
    elif choice == "1":
        upnext.auto_dj_transition(current_song, current_artist)
    elif choice == "2":
        upnext.queue_one_song(current_song, current_artist)
    elif choice == "3":
        upnext.queue_ten_songs(current_song, current_artist)
    elif choice == "4":
        upnext.queue_playlist(current_song, current_artist)
    elif choice == "5":
        upnext.queue_theme_playlist()
    elif choice == "6":
        upnext.song_insight(current_song, current_artist)
    elif choice == "t":
        upnext.toggle_playlist_mode()
        notify(f"Queue mode: {'Playlist' if upnext.mode == 'playlist' else 'Smart'}", style="magenta")
    elif choice == "toggle_play":
        playback = spotify_controller.sp.current_playback()
        if playback and playback.get("is_playing"):
            spotify_controller.pause()
            notify("⏸ Paused playback", style="yellow")
        else:
            spotify_controller.resume()
            notify("▶️ Resumed playback", style="yellow")
    elif choice == "next":
        spotify_controller.next_track()
        notify("⏭ Skipped to next track.", style="yellow")
    elif choice == "prev":
        spotify_controller.previous_track()
        notify("⏮ Went back to previous track.", style="yellow")
    elif choice == "vol_up":
        spotify_controller.change_volume(+10)
    elif choice == "vol_down":
        spotify_controller.change_volume(-10)
    elif choice == "s":
        saved_path = os.path.expanduser("~/.radiofreedj/saved_songs.json")
        os.makedirs(os.path.dirname(saved_path), exist_ok=True)
        song_data = {
            "track_name": current_song,
            "artist_name": current_artist,
            "timestamp": datetime.now().isoformat()
        }
        try:
            if os.path.exists(saved_path):
                with open(saved_path, "r") as f:
                    data = json.load(f)
            else:
                data = []
            data.append(song_data)
            with open(saved_path, "w") as f:
                json.dump(data, f, indent=2)
            notify(f"💾 Saved: {current_song} by {current_artist}", style="green")
        except Exception as e:
            notify(f"Error saving song: {e}", style="red")
    elif choice == "d":
        log_song_history(current_song, current_artist, queued_by="user", skipped=True)
        notify(f"👎 Marked as disliked: {current_song}", style="red")
    else:
        notify("❌ Invalid menu option.", style="red")

def sync_with_lastfm(song_name, artist_name):
    notify("📡 Placeholder: Last.fm sync for this track would be triggered here.", style="blue")

def main():
    global last_song, show_lyrics, show_gpt_log, lyrics_view_mode, lyrics_cursor
    try:
        threading.Thread(target=read_input, daemon=True).start()
        console.print("[green]🚀 Starting FreeRadioDJ...[/green]\n")
        song_name, artist_name = spotify_controller.get_current_song()
        while not song_name:
            console.print("[yellow]⏳ Waiting for Spotify to start playback...[/yellow]")
            time.sleep(3)
            song_name, artist_name = spotify_controller.get_current_song()
        while True:
            try:
                playback = spotify_controller.sp.current_playback()
                item = playback.get("item", {}) if playback else {}
                duration_ms = item.get("duration_ms", 0)
            except ReadTimeout:
                notify("Spotify API timeout (startup), retrying...", style="red")
                continue
            if duration_ms >= 1000:
                break
            time.sleep(0.2)
        album_name = item.get("album", {}).get("name", "")
        last_song = (song_name, artist_name)
        lyrics_manager.start(song_name, artist_name, album_name, duration_ms)
        console.print("[dim]Press [bold]l[/bold] to toggle lyrics, [bold]g[/bold] for GPT log, or press keys (1–6, t, arrows, space, +, -).[/dim]")
        with Live(refresh_per_second=2, screen=True) as live:
            while True:
                try:
                    playback = spotify_controller.sp.current_playback()
                except (ReadTimeout, RequestException) as e:
                    notify(f"Spotify API error: {e}", style="red")
                    continue
                if not playback or not playback.get("item"):
                    time.sleep(1)
                    continue
                item = playback["item"]
                current_song = item["name"]
                current_artist = item["artists"][0]["name"]
                progress_ms = playback.get("progress_ms", 0)
                if (current_song, current_artist) != last_song:
                    last_song = (current_song, current_artist)
                    while True:
                        try:
                            play2 = spotify_controller.sp.current_playback()
                            item2 = play2.get("item", {}) if play2 else {}
                            duration_ms = item2.get("duration_ms", 0)
                        except (ReadTimeout, RequestException):
                            time.sleep(0.2)
                            continue
                        if duration_ms >= 1000:
                            break
                        time.sleep(0.2)
                    album_name = item2.get("album", {}).get("name", "")
                    notify(f"🔄 Track changed: {current_song} by {current_artist}", style="cyan")
                    lyrics_manager.start(current_song, current_artist, album_name, duration_ms)
                    sync_with_lastfm(current_song, current_artist)
                lyrics_manager.sync(progress_ms)
                live.update(create_layout(current_song, current_artist))
                if not user_input_queue.empty():
                    choice = user_input_queue.get()
                    process_user_input(choice, current_song, current_artist)
                time.sleep(0.5)
    except KeyboardInterrupt:
        console.print("\n[bold red]⏹ Exiting FreeRadioDJ... Goodbye![/bold red]")
    except Exception as e:
        logger.exception("Unexpected error in main loop")
        console.print(f"\n[red]❌ Unexpected error in main loop: {e}[/red]")
        console.print("\n[bold red]⏹ Exiting FreeRadioDJ... Goodbye![/bold red]")

if __name__ == "__main__":
    main()



=== spotify_utils.py ===
# spotify_utils.py

import os
import spotipy
from spotipy.oauth2 import SpotifyOAuth
from dotenv import load_dotenv

# Load environment variables
load_dotenv()



class SpotifyController:
    def __init__(self):
        self.sp = spotipy.Spotify(
            auth_manager=SpotifyOAuth(
                scope=(
                    "user-read-playback-state "
                    "user-modify-playback-state "
                    "user-read-currently-playing "
                    "user-read-private "
                    "user-library-read"
                ),
                client_id=os.getenv("SPOTIPY_CLIENT_ID"),
                client_secret=os.getenv("SPOTIPY_CLIENT_SECRET"),
                redirect_uri=os.getenv("SPOTIPY_REDIRECT_URI"),
            )
        )

    def get_current_song(self):
        try:
            current = self.sp.current_playback()
            if not current or not current.get("item"):
                return None, None
            song_name = current["item"]["name"]
            artist_name = current["item"]["artists"][0]["name"]
            return song_name, artist_name
        except Exception as e:
            print(f"Error fetching current song: {e}")
            return None, None

    def search_track(self, track_name, artist_name):
        try:
            query = f"track:{track_name} artist:{artist_name}"
            result = self.sp.search(q=query, type="track", limit=1)
            tracks = result.get("tracks", {}).get("items", [])
            return tracks[0]["uri"] if tracks else None
        except Exception as e:
            print(f"Error searching track: {e}")
            return None

    def play_track(self, track_uri):
        try:
            devices = self.sp.devices().get('devices', [])
            if not devices:
                print("No active Spotify device.")
                return
            device_id = devices[0]['id']
            self.sp.transfer_playback(device_id, force_play=True)
            self.sp.start_playback(uris=[track_uri])
        except Exception as e:
            print(f"Error playing track: {e}")

    def pause(self):
        try:
            self.sp.pause_playback()
        except Exception as e:
            print(f"Error pausing: {e}")

    def resume(self):
        try:
            self.sp.start_playback()
        except Exception as e:
            print(f"Error resuming: {e}")

    def next(self):
        try:
            self.sp.next_track()
        except Exception as e:
            print(f"Error skipping: {e}")

    def previous(self):
        try:
            self.sp.previous_track()
        except Exception as e:
            print(f"Error going back: {e}")

    def set_volume(self, vol_percent):
        try:
            self.sp.volume(vol_percent)
        except Exception as e:
            print(f"Error setting volume: {e}")

    def add_to_queue(self, track_uri):
        try:
            self.sp.add_to_queue(track_uri)
        except Exception as e:
            print(f"Error adding to queue: {e}")

    def pause(self):
        try:
            self.sp.pause_playback()
        except Exception as e:
            print(f"Error pausing playback: {e}")

    def resume(self):
        try:
            self.sp.start_playback()
        except Exception as e:
            print(f"Error resuming playback: {e}")

    def next_track(self):
        try:
            self.sp.next_track()
        except Exception as e:
            print(f"Error skipping to next track: {e}")

    def previous_track(self):
        try:
            self.sp.previous_track()
        except Exception as e:
            print(f"Error going to previous track: {e}")

    def change_volume(self, delta):
        try:
            playback = self.sp.current_playback()
            if not playback or "device" not in playback:
                print("No active device.")
                return
            current_vol = playback["device"]["volume_percent"]
            new_vol = min(100, max(0, current_vol + delta))
            self.sp.volume(new_vol)
            print(f"🔊 Volume set to {new_vol}%")
        except Exception as e:
            print(f"Error changing volume: {e}")
    



=== upnext.py ===
import json
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.prompt import Prompt


class UpNextManager:
    @property
    def playlist_mode(self):
        return self.mode == "playlist"

    def __init__(self, gpt_dj, spotify_controller, prompt_templates):
        self.dj = gpt_dj
        self.sp = spotify_controller
        self.templates = prompt_templates
        self.queue = []
        self.mode = "smart"
        self.console = Console()

    def toggle_playlist_mode(self):
        self.mode = "playlist" if self.mode == "smart" else "smart"
        self.console.print(Panel(f"[bold cyan]Switched to [green]{self.mode}[/green] mode.[/bold cyan]"))

    def auto_dj_transition(self, current_song, current_artist):
        prompt = self.templates["auto_dj"].format(song_name=current_song, artist_name=current_artist)
        resp = self.dj.ask(prompt)
        self.dj.logger.info(f"[auto_dj_transition] Prompt:\n{prompt}")
        self.dj.logger.info(f"[auto_dj_transition] Raw Response:\n{resp}")

        try:
            parsed = json.loads(resp.replace("'", '"'))
            track_name = parsed.get("track_name")
            artist_name = parsed.get("artist_name")
            if track_name and artist_name:
                self.queue.insert(0, {"track_name": track_name, "artist_name": artist_name})
                self.dj.logger.info(f"Queued track: {track_name} by {artist_name}")
            else:
                self.dj.logger.warning("Missing track data in GPT response.")
        except Exception as e:
            self.dj.logger.error(f"Error parsing GPT response as JSON: {e}")
            return

        if not self.queue:
            return

        next_track = self.queue.pop(0)
        intro = self._generate_radio_intro(next_track["track_name"], next_track["artist_name"])
        self.console.print(Panel(intro, title=" DJ Intro", border_style="blue"))

        track_uri = self.sp.search_track(next_track["track_name"], next_track["artist_name"])
        if track_uri:
            self.sp.play_track(track_uri)
        else:
            self.console.print(
                f"[red] Could not find: {next_track['track_name']} by {next_track['artist_name']}[/red]"
            )

    def queue_one_song(self, song_name, artist_name):
        prompt = self.templates["recommend_next_song"].format(song_name=song_name, artist_name=artist_name)
        response = self.dj.ask(prompt)
        if response:
            try:
                track = json.loads(response.replace("'", '"'))
                self.queue.append(track)
                self.console.print(f"[green]➕ Queued:[/green] {track['track_name']} by {track['artist_name']}")
            except json.JSONDecodeError:
                self.console.print("[red]Failed to parse GPT response.[/red]")
        else:
            self.console.print("[red]No song queued.[/red]")

    def queue_ten_songs(self, song_name, artist_name):
        prompt = self.templates["recommend_next_ten_songs"].format(song_name=song_name, artist_name=artist_name)
        response = self.dj.ask(prompt)
        if response:
            lines = response.strip().split("\n")
            count = 0
            for line in lines:
                if "." in line and " by " in line:
                    try:
                        title = line.split(". ", 1)[1]
                        track, artist = title.rsplit(" by ", 1)
                        self.queue.append({"track_name": track.strip(), "artist_name": artist.strip()})
                        count += 1
                    except Exception:
                        continue
            self.console.print(f"[green]➕ Queued {count} songs.[/green]")
        else:
            self.console.print("[red]No songs queued.[/red]")

    def queue_playlist(self, song_name, artist_name):
        prompt = self.templates["create_playlist"].format(song_name=song_name, artist_name=artist_name)
        self._parse_and_queue_playlist(prompt)

    def queue_theme_playlist(self):
        theme = Prompt.ask("Enter a theme (e.g., focus, happy, roadtrip)").strip()
        prompt = self.templates["theme_based_playlist"].format(theme=theme)
        self._parse_and_queue_playlist(prompt)

    def _parse_and_queue_playlist(self, prompt):
        response = self.dj.ask(prompt)
        if response:
            lines = response.strip().split("\n")
            count = 0
            for line in lines:
                if "." in line and " by " in line:
                    try:
                        title = line.split(". ", 1)[1]
                        track, artist = title.rsplit(" by ", 1)
                        self.queue.append({"track_name": track.strip(), "artist_name": artist.strip()})
                        count += 1
                    except Exception:
                        continue
            self.mode = "playlist"
            self.console.print(f"[green]📀 Playlist queued with {count} tracks.[/green]")
        else:
            self.console.print("[red]Playlist creation failed.[/red]")

    def song_insight(self, song_name, artist_name):
        prompt = self.templates["song_insights"].format(song_name=song_name, artist_name=artist_name)
        response = self.dj.ask(prompt)
        if response:
            self.console.print(Panel(response, title=" Insight", border_style="cyan"))
        else:
            self.console.print("[red]No insight generated.[/red]")

    def _generate_radio_intro(self, track_name, artist_name):
        prompt = self.templates["generate_radio_intro"].format(track_name=track_name, artist_name=artist_name)
        response = self.dj.ask(prompt)
        return response or " [DJ dead air] No intro available."



=== view_history.py ===
#!/usr/bin/env python3

import json
import os
from datetime import datetime
from rich.console import Console
from rich.table import Table

HISTORY_FILE = os.path.expanduser("~/RadioFree/logs/song_history.jsonl")

def load_history():
    """Load song history entries from the JSONL file."""
    if not os.path.exists(HISTORY_FILE):
        print("No song history found.")
        return []

    with open(HISTORY_FILE, "r") as f:
        return [json.loads(line.strip()) for line in f if line.strip()]

def display_history(entries, limit=25):
    """Render a table view of recent song history."""
    console = Console()
    table = Table(show_header=True, header_style="bold magenta")
    table.add_column("Time", style="dim", width=19)
    table.add_column("Track")
    table.add_column("Artist")
    table.add_column("Queued By", justify="center")
    table.add_column("Liked", justify="center")
    table.add_column("Skipped", justify="center")

    for entry in entries[-limit:]:
        table.add_row(
            datetime.fromisoformat(entry["timestamp"]).strftime("%m-%d %H:%M"),
            entry.get("track_name", "Unknown"),
            entry.get("artist_name", "Unknown"),
            entry.get("queued_by", "?"),
            "✔" if entry.get("liked") else "",
            "✘" if entry.get("skipped") else ""
        )

    console.print(table)

if __name__ == "__main__":
    history = load_history()
    display_history(history)

    print("\n[placeholder] 🚧 Last.fm sync integration coming soon.")



